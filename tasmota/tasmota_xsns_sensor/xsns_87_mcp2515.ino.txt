/*
  xsns_87_mcp2515.ino - MCP2515 CAN bus support for Tasmota

  Copyright (C) 2021  Marius Bezuidenhout

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  This program is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifdef USE_SPI
#ifdef USE_MCP2515
/*********************************************************************************************\
 * MCP2515 - Microchip CAN controller
 *
 * Connections:
 * MCP2515  ESP8266         Tasmota
 * -------  --------------  ----------
 *  INT     not used
 *  SCK     GPIO14          SPI CLK
 *  SI      GPIO13          SPI MOSI
 *  SO      GPIO12          SPI MISO
 *  CS      GPIO0..5,15,16  MCP2515
 *  Gnd     Gnd
 *  VCC     Vin/5V
\*********************************************************************************************/

#define XSNS_87              87

// set defaults if not defined
#ifndef MCP2515_BITRATE
  #define MCP2515_BITRATE  CAN_250KBPS
#endif

#ifndef MCP2515_CLOCK
  #define MCP2515_CLOCK  MCP_16MHZ
#endif

#ifndef MCP2515_MAX_FRAMES
  #define MCP2515_MAX_FRAMES 14
#endif

#ifndef CAN_KEEP_ALIVE_SECS
  #define CAN_KEEP_ALIVE_SECS 300
#endif

#ifndef MCP2515_TIMEOUT
  #define MCP2515_TIMEOUT 10
#endif

#ifndef MCP2515_BMS_CLIENT
  #define MCP2515_BMS_CLIENT
  // Look for Freedom Won BMS data in CAN message
  #ifndef MCP2515_BMS_FREEDWON
    #define MCP2515_BMS_FREEDWON
  #endif  // MCP2515_BMS_FREEDWON
#endif // MCP2515_BMS_CLIENT

#include "mcp2515.h"

#ifdef MCP2515_BMS_CLIENT

  #define BMS_NAME                0x1
  #define BMS_SOC                 0x2
  #define BMS_SOH                 0x4
  #define BMS_TEMP                0x8
  #define BMS_TEMP2              0x10
  #define BMS_TEMP3              0x20
  #define BMS_DISCHARGE_AMP_MAX  0x40
  #define BMS_VOLT               0x80
  #define BMS_AMP               0x100
  #define BMS_TEMPL             0x200
  #define BMS_TEMPH             0x400
  #define BMS_MODEL             0x800
  #define BMS_FIRMWARE_VER     0x1000
  #define BMS_MANUFACTURER     0x2000
  #define BMS_SERIAL           0x4000
  #define BMS_CELL_VOLT        0x8000
  #define BMS_MESSAGE 		  0x10000
  #define BMS_SSOC  		  0x20000
  #define BMS_RC    		  0x40000
  #define BMS_VSOC  		  0x80000
  #define BMS_CELL_DIFF      0x100000
  #define BMS_ENERGY         0x200000
  #define BMS_BMSCUTUM       0x400000
  #define BMS_WARNINGS       0x800000
  #define BMS_ERRORS        0x1000000
  #define BMS_INPUTS        0x2000000
  #define BMS_OUTPUTS       0x4000000

struct BMS_Struct {
  uint32_t  setFields; // Bitwise fields set list
  char      name[17];
  uint16_t  stateOfCharge;
  int16_t   battTemp1; // Div 100
  int16_t   battTemp2; // Div 100
  int16_t   battTemp3; // Div 100
  int16_t   maxDischargeCurrent; // Div 10
  uint16_t  battVoltage; // Div 100
  int16_t   battAmp; // Div 10
  int8_t    battTempL; // Div 10
  int8_t    battTempH;
  uint8_t   battMaxCellVoltDiff;
  uint16_t  model;
  uint16_t  firmwareVer;
  uint16_t  battCellVoltage[14];  //Div 1000
  uint32_t  battEnergy;
  uint16_t  BMScutum;
  uint8_t   warnings;
  uint8_t   errors;
  uint8_t   inputs;
  uint8_t   outputs;
  char      manuf[7];
  char 		  message1[9];
  char 		  message2[9];
  char 		  bmscutummessage[100];
  char 		  warningsmessage[100];
  char 		  errorsmessage[100];
  char 		  inputsmessage[100];
  char 		  outputsmessage[100];
  char      serialNr[17];
  uint32_t  hilf[2];
} bms;


#endif

int8_t mcp2515_init_status = 1;

uint32_t lastFrameRecv = 0;
struct can_frame canFrame;
MCP2515 *mcp2515 = nullptr;

char c2h(char c)
{
  return "0123456789ABCDEF"[0x0F & (unsigned char)c];
}

void MCP2515_FrameSizeError(uint8_t len, uint32_t id) {
  AddLog(LOG_LEVEL_DEBUG, PSTR("MCP2515: Unexpected length (%d) for ID 0x%x"), len, id);
}    

void MCP2515_Init(void) {
  mcp2515 = new MCP2515(5);
  if (MCP2515::ERROR_OK != mcp2515->reset()) {
    AddLog(LOG_LEVEL_ERROR, PSTR("MCP2515: Failed to reset module"));
    mcp2515_init_status = 0;
  }

  if (MCP2515::ERROR_OK != mcp2515->setBitrate(MCP2515_BITRATE, MCP2515_CLOCK)) {
    AddLog(LOG_LEVEL_ERROR, PSTR("MCP2515: Failed to set module bitrate"));
    mcp2515_init_status = 0;
  }
  
  if (mcp2515_init_status && MCP2515::ERROR_OK != mcp2515->setNormalMode()) {
    AddLog(LOG_LEVEL_ERROR, PSTR("MCP2515: Failed to set normal mode"));
    mcp2515_init_status = 0;
  }
#ifdef MCP2515_BMS_FREEDWON
  // TODO: Filter CAN bus messages
  //mcp2515->setFilterMask();
  //mcp2515->setFilter();
#endif
}

void MCP2515_Read() {
  uint8_t nCounter = 0;
  bool checkRcv;
  if (mcp2515_init_status) {

    checkRcv = mcp2515->checkReceive();

    while (checkRcv && nCounter <= MCP2515_MAX_FRAMES) {
      mcp2515->checkReceive();
      nCounter++;
      if (mcp2515->readMessage(&canFrame) == MCP2515::ERROR_OK) {
        lastFrameRecv = TasmotaGlobal.uptime;
#ifdef MCP2515_BMS_CLIENT
  #ifdef MCP2515_BMS_FREEDWON
      strcpy (bms.manuf, "S01");
      switch (canFrame.can_id) {
        // Voltage/Current/Temperature
        case 0x181:
          if (8 == canFrame.can_dlc) {
            bms.stateOfCharge = (canFrame.data[1]);
            bms.battTempL   = (canFrame.data[2]); // Convert to fahrenheit if SetOpion8 is set
            bms.battTempH   = (canFrame.data[3]); // Convert to fahrenheit if SetOpion8 is set
            bms.battVoltage = (canFrame.data[5] << 8) | canFrame.data[4];
            bms.battAmp     = (canFrame.data[7] << 8) | canFrame.data[6];
            bms.setFields  |= BMS_SOC | BMS_TEMPL | BMS_TEMPH | BMS_VOLT | BMS_AMP;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
        // Charge/Discharge parameters
        case 0x184:
          char hilfstr[10];
          int len;
          if (8 == canFrame.can_dlc) {
              memset(bms.bmscutummessage, 0, 100);
              memset(bms.warningsmessage, 0, 100);
              memset(bms.errorsmessage, 0, 100);
              memset(bms.inputsmessage, 0, 100);
              memset(bms.outputsmessage, 0, 100);
            bms.BMScutum            = (canFrame.data[1] << 8) | canFrame.data[0];
            if (bms.BMScutum & 1) {
              strcat(bms.bmscutummessage,"ON");
            }  
            if (bms.BMScutum & 2) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "DSCH" : ", DSCH");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 4) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "CHGi" : ", CHGi");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 8) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "CHGe" : ", CHGe");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 16) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "CHGD" : ", CHGD");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 32) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "WarnMode" : ", WarnMode");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 64) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "LEDr" : ", LEDr");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 128) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "Alarm" : ", Alarm");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 256) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "CC" : ", CC");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 512) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "CV" : ", CV");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 1024) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "Bal" : ", Bal");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 2048) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "VKL" : ", VKL");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 4096) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "OFD" : ", OFD");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 8192) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "INH" : ", INH");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            if (bms.BMScutum & 16384) {
              len = strlen(bms.bmscutummessage);
              strcpy(hilfstr, (len = 0) ? "UVPD" : ", UVPD");
              strcat(bms.bmscutummessage, hilfstr);
            }  
            bms.warnings            = canFrame.data[2];
            if (bms.warnings & 1) {
              strcat(bms.warningsmessage, "WOV");
            }  
            if (bms.warnings & 2) {
              len = strlen(bms.warningsmessage);
              strcpy(hilfstr, (len = 0) ? "WUV" : ", WUV");
              strcat(bms.warningsmessage, hilfstr);
            }  
            if (bms.warnings & 4) {
              len = strlen(bms.warningsmessage);
              strcpy(hilfstr, (len = 0) ? "WOCD" : ", WOCD");
              strcat(bms.warningsmessage, hilfstr);
            }  
            if (bms.warnings & 8) {
              len = strlen(bms.warningsmessage);
              strcpy(hilfstr, (len = 0) ? "WOCR" : ", WOCR");
              strcat(bms.warningsmessage, hilfstr);
            }  
            if (bms.warnings & 16) {
              len = strlen(bms.warningsmessage);
              strcpy(hilfstr, (len = 0) ? "WOCC" : ", WOCC");
              strcat(bms.warningsmessage, hilfstr);
            }  
            if (bms.warnings & 32) {
              len = strlen(bms.warningsmessage);
              strcpy(hilfstr, (len = 0) ? "WOT" : ", WOT");
              strcat(bms.warningsmessage, hilfstr);
            }  
            if (bms.warnings & 64) {
              len = strlen(bms.warningsmessage);
              strcpy(hilfstr, (len = 0) ? "WUT" : ", WUT");
              strcat(bms.warningsmessage, hilfstr);
            }  
            if (bms.warnings & 128) {
              len = strlen(bms.warningsmessage);
              strcpy(hilfstr, (len = 0) ? "WLS" : ", WLS");
              strcat(bms.warningsmessage, hilfstr);
            }  
            bms.errors              = canFrame.data[3];
            if (bms.errors & 1) {
              strcat(bms.errorsmessage, "LOV");
            }  
            if (bms.errors & 2) {
              len = strlen(bms.errorsmessage);
              strcpy(hilfstr, (len = 0) ? "LUV" : ", LUV");
              strcat(bms.errorsmessage, hilfstr);
            }  
            if (bms.errors & 4) {
              len = strlen(bms.errorsmessage);
              strcpy(hilfstr, (len = 0) ? "LOCD" : ", LOCD");
              strcat(bms.errorsmessage, hilfstr);
            }  
            if (bms.errors & 8) {
              len = strlen(bms.errorsmessage);
              strcpy(hilfstr, (len = 0) ? "LOCR" : ", LOCR");
              strcat(bms.errorsmessage, hilfstr);
            }  
            if (bms.errors & 16) {
              len = strlen(bms.errorsmessage);
              strcpy(hilfstr, (len = 0) ? "LOT" : ", LOT");
              strcat(bms.errorsmessage, hilfstr);
            }  
            if (bms.errors & 32) {
              len = strlen(bms.errorsmessage);
              strcpy(hilfstr, (len = 0) ? "LUT" : ", LUT");
              strcat(bms.errorsmessage, hilfstr);
            }  
            if (bms.errors & 64) {
              len = strlen(bms.errorsmessage);
              strcpy(hilfstr, (len = 0) ? "SCD" : ", SCD");
              strcat(bms.errorsmessage, hilfstr);
            }  
            bms.inputs              = canFrame.data[4];
            if (bms.inputs & 1) {
              strcat(bms.inputsmessage, "Key_in");
            }  
            if (bms.inputs & 2) {
              len = strlen(bms.inputsmessage);
              strcpy(hilfstr, (len = 0) ? "Chg_ext" : ", Chg_ext");
              strcat(bms.inputsmessage, hilfstr);
            }  
            if (bms.inputs & 4) {
              len = strlen(bms.inputsmessage);
              strcpy(hilfstr, (len = 0) ? "Chg_ob" : ", Chg_ob");
              strcat(bms.inputsmessage, hilfstr);
            }  
            if (bms.inputs & 8) {
              len = strlen(bms.inputsmessage);
              strcpy(hilfstr, (len = 0) ? "PiezoTap" : ", PiezoTap");
              strcat(bms.inputsmessage, hilfstr);
            }  
            if (bms.inputs & 16) {
              len = strlen(bms.inputsmessage);
              strcpy(hilfstr, (len = 0) ? "Accel" : ", Accel");
              strcat(bms.inputsmessage, hilfstr);
            }  
            bms.outputs             = canFrame.data[5];
            if (bms.outputs & 1) {
              strcat(bms.outputsmessage, "K_plus");
            }  
            if (bms.outputs & 2) {
              len = strlen(bms.outputsmessage);
              strcpy(hilfstr, (len = 0) ? "PMOS_I" : ", PMOS_I");
              strcat(bms.outputsmessage, hilfstr);
            }  
            if (bms.outputs & 4) {
              len = strlen(bms.outputsmessage);
              strcpy(hilfstr, (len = 0) ? "PMOS_E" : ", PMOS_E");
              strcat(bms.outputsmessage, hilfstr);
            }  
            if (bms.outputs & 8) {
              len = strlen(bms.outputsmessage);
              strcpy(hilfstr, (len = 0) ? "Kch_ob" : ", Kch_ob");
              strcat(bms.outputsmessage, hilfstr);
            }  
            if (bms.outputs & 16) {
              len = strlen(bms.outputsmessage);
              strcpy(hilfstr, (len = 0) ? "Heater" : ", Heater");
              strcat(bms.outputsmessage, hilfstr);
            }  
            if (bms.outputs & 32) {
              len = strlen(bms.outputsmessage);
              strcpy(hilfstr, (len = 0) ? "Fan_a" : ", Fan_a");
              strcat(bms.outputsmessage, hilfstr);
            }  
            if (bms.outputs & 64) {
              len = strlen(bms.outputsmessage);
              strcpy(hilfstr, (len = 0) ? "Fan_b" : ", Fan_b");
              strcat(bms.outputsmessage, hilfstr);
            }  
            bms.setFields          |= BMS_BMSCUTUM | BMS_WARNINGS | BMS_ERRORS | BMS_INPUTS | BMS_OUTPUTS;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
        // Cell Voltage parameters
        case 0x185:
          if (8 == canFrame.can_dlc) {
            bms.battCellVoltage[0]   = (canFrame.data[1] << 8) | canFrame.data[0];
            bms.battCellVoltage[1]   = (canFrame.data[3] << 8) | canFrame.data[2];
            bms.battCellVoltage[2]   = (canFrame.data[5] << 8) | canFrame.data[4];
            bms.battCellVoltage[3]   = (canFrame.data[7] << 8) | canFrame.data[6];
            bms.setFields          |= BMS_CELL_VOLT;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
        case 0x186:
          if (8 == canFrame.can_dlc) {
            bms.battCellVoltage[4]   = (canFrame.data[1] << 8) | canFrame.data[0];
            bms.battCellVoltage[5]   = (canFrame.data[3] << 8) | canFrame.data[2];
            bms.battCellVoltage[6]   = (canFrame.data[5] << 8) | canFrame.data[4];
            bms.battCellVoltage[7]   = (canFrame.data[7] << 8) | canFrame.data[6];
            bms.setFields          |= BMS_CELL_VOLT;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
        case 0x187:
          if (8 == canFrame.can_dlc) {
            bms.battCellVoltage[8]   = (canFrame.data[1] << 8) | canFrame.data[0];
            bms.battCellVoltage[9]   = (canFrame.data[3] << 8) | canFrame.data[2];
            bms.battCellVoltage[10]  = (canFrame.data[5] << 8) | canFrame.data[4];
            bms.battCellVoltage[11]  = (canFrame.data[7] << 8) | canFrame.data[6];
            bms.setFields          |= BMS_CELL_VOLT;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
        case 0x188:
          if (6 == canFrame.can_dlc) {
            bms.battCellVoltage[12]   = (canFrame.data[1] << 8) | canFrame.data[0];
            bms.battCellVoltage[13]   = (canFrame.data[3] << 8) | canFrame.data[2];
            bms.setFields          |= BMS_CELL_VOLT;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
          // Temperature
        case 0x189:
          if (8 == canFrame.can_dlc) {
            bms.battTemp1   = (canFrame.data[3] << 8) | canFrame.data[2];
            bms.battTemp2   = (canFrame.data[5] << 8) | canFrame.data[4];
            bms.battTemp3   = (canFrame.data[7] << 8) | canFrame.data[6];
            bms.setFields          |= BMS_TEMP;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
          // Energy
        case 0x1C0:
          if (8 == canFrame.can_dlc) {
            bms.hilf[0] = (canFrame.data[1] << 8) | canFrame.data[0];
            bms.hilf[1] = (canFrame.data[3] << 8) | canFrame.data[2];
            bms.battEnergy   = (bms.hilf[1] << 16) | bms.hilf[0];
            bms.setFields          |= BMS_ENERGY;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
          break;
        // Message: CHARGING/CHARGED
        case 0x310:
          for (int i = 0; i < canFrame.can_dlc; i++) {
            bms.message1[i] = canFrame.data[i];
          }
          bms.setFields |= BMS_MESSAGE;
          bms.message1[canFrame.can_dlc] = 0; // Ensure that name is null terminated
          break;
        // Message: STANDARD
        case 0x313:
          for (int i = 0; i < canFrame.can_dlc; i++) {
            bms.message2[i] = canFrame.data[i];
          }
          bms.setFields |= BMS_MESSAGE;
          bms.message2[canFrame.can_dlc] = 0; // Ensure that name is null terminated
          break;
         // battMaxCellVoltDiff 
        case 0x18E:
          char canMsg1[17];
          canMsg1[0] = 0;
          for (int i = 0; i < canFrame.can_dlc; i++) {
            canMsg1[i*2] = c2h(canFrame.data[i]>>4);
            canMsg1[i*2+1] = c2h(canFrame.data[i]);
          }
          if (canFrame.can_dlc > 0) {
            canMsg1[(canFrame.can_dlc - 1) * 2 + 2] = 0;
          }
          AddLog(LOG_LEVEL_INFO, PSTR("MCP2515: Received message 0x%s from ID 0x%x"), canMsg1, (uint32_t)canFrame.can_id);
          if (8 == canFrame.can_dlc) {
            bms.battMaxCellVoltDiff = canFrame.data[3];
            bms.setFields          |= BMS_CELL_DIFF;
          } else {
            MCP2515_FrameSizeError(canFrame.can_dlc, canFrame.can_id);
          }
            
           break;
        default:
          char canMsg[17];
          canMsg[0] = 0;
          for (int i = 0; i < canFrame.can_dlc; i++) {
            canMsg[i*2] = c2h(canFrame.data[i]>>4);
            canMsg[i*2+1] = c2h(canFrame.data[i]);
          }
          if (canFrame.can_dlc > 0) {
            canMsg[(canFrame.can_dlc - 1) * 2 + 2] = 0;
          }
          AddLog(LOG_LEVEL_DEBUG, PSTR("MCP2515: Received message 0x%s from ID 0x%x"), canMsg, (uint32_t)canFrame.can_id);
          break;
      }
  #endif // MCP2515_BMS_FREEDWON
#endif // MCP2515_BMS_CLIENT
      } else if (mcp2515->checkError()) {
        uint8_t errFlags = mcp2515->getErrorFlags();
          mcp2515->clearRXnOVRFlags();
         AddLog(LOG_LEVEL_DEBUG, PSTR("MCP2515: Received error %d"), errFlags);
          break;
      }
    }

#ifdef MCP2515_BMS_FREEDWON
/*    if (!(TasmotaGlobal.uptime%CAN_KEEP_ALIVE_SECS) && TasmotaGlobal.uptime>60) {
      canFrame.can_id  = 0x305;
      canFrame.can_dlc = 0;
      if (MCP2515::ERROR_OK != mcp2515->sendMessage(&canFrame)) {
        AddLog(LOG_LEVEL_ERROR, PSTR("MCP2515: Failed to send keep alive frame"));
      } 
    } */
#endif
  }
}

void MCP2515_Show(bool Json) {
  if (Json) {
    if (lastFrameRecv > 0 && TasmotaGlobal.uptime - lastFrameRecv <= MCP2515_TIMEOUT) {
#ifdef MCP2515_BMS_CLIENT
     if (bms.setFields & BMS_SOC) {
        bool jsonFirstField = true;
        ResponseAppend_P(PSTR(",\"%s\":{"), bms.manuf);

        if (bms.setFields & BMS_SOC) {
          ResponseAppend_P(PSTR("\"SOC\":%d"), bms.stateOfCharge);
          jsonFirstField = false;
        }
        if (bms.setFields & BMS_VOLT) {
          ResponseAppend_P(PSTR("%s\"BattVolt\":%d.%d"), jsonFirstField ? PSTR("") : PSTR(","), bms.battVoltage / 10, bms.battVoltage % 10);
          jsonFirstField = false;
        }
        if (bms.setFields & BMS_AMP) {
          int8_t bmsModNeg = 1;
          if (bms.battAmp < 0) {
            bmsModNeg = -1;
          }
          ResponseAppend_P(PSTR("%s\"BattAmp\":%d.%d"), jsonFirstField ? PSTR("") : PSTR(","), bms.battAmp / 10, (bms.battAmp % 10) * bmsModNeg);
          jsonFirstField = false;
        }
        if (bms.setFields & BMS_TEMPL) {
          ResponseAppend_P(PSTR("%s\"BattTempL\":%d"), jsonFirstField ? PSTR("") : PSTR(","), bms.battTempL);
          jsonFirstField = false;
        }
        if (bms.setFields & BMS_TEMPH) {
          ResponseAppend_P(PSTR("%s\"BattTempH\":%d"), jsonFirstField ? PSTR("") : PSTR(","), bms.battTempH);
          jsonFirstField = false;
        }
        if (bms.setFields & BMS_CELL_VOLT) {
          char ampStr3[6];
          dtostrf((float(bms.battCellVoltage[0]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_01\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[1]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_02\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[2]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_03\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[3]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_04\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[4]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_05\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[5]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_06\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[6]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_07\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[7]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_08\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[8]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_09\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[9]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_10\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[10]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_11\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[11]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_12\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[12]) / 1000), 5, 3, ampStr3);
				  ResponseAppend_P(PSTR("%s\"Zelle_13\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          dtostrf((float(bms.battCellVoltage[13]) / 1000), 5, 3, ampStr3);
 				  ResponseAppend_P(PSTR("%s\"Zelle_14\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr3);
          jsonFirstField = false; 
        }
        if (bms.setFields & BMS_ENERGY) {
          char ampStr4[6];
          dtostrf((float(bms.battEnergy) / 3600), 5, 1, ampStr4);
			    ResponseAppend_P(PSTR("%s\"Energie\":%s"),  jsonFirstField ? PSTR("") : PSTR(","), ampStr4);
          jsonFirstField = false; 
		}		    
         

        ResponseAppend_P(PSTR("}"));
      }
    } else {
      bms.setFields = 0;
#endif // MCP2515_BMS_CLIENT
    }
#ifdef USE_WEBSERVER
  } else {
  #ifdef MCP2515_BMS_CLIENT
//    if (bms.setFields & BMS_SOC) {
      if (bms.setFields & BMS_MESSAGE) {
        WSContentSend_PD(PSTR("{s}%s  %s{m} %s{e}"), bms.manuf, bms.message1, bms.message2);
      }
      if (bms.setFields & BMS_SOC) {
        WSContentSend_PD(HTTP_SNS_SOC, bms.manuf, bms.stateOfCharge);
      }
      if (bms.setFields & BMS_VOLT) {
        char voltStr[6];
        dtostrf((float(bms.battVoltage) / 10), 5, 1, voltStr);
        WSContentSend_PD(PSTR("{s}%s " D_VOLTAGE "{m}%s " D_UNIT_VOLT "{e}"), bms.manuf, voltStr);
//        WSContentSend_Voltage(bms.manuf, (float(bms.battVoltage) / 10));
      }
      if (bms.setFields & BMS_AMP) {
        char ampStr[6];
        dtostrf((float(bms.battAmp) / 10), 5, 1, ampStr);
        WSContentSend_PD(PSTR("{s}%s " D_CURRENT "{m}%s " D_UNIT_AMPERE "{e}"), bms.manuf, ampStr);
      }
      if (bms.setFields & BMS_TEMP) {
        char tempStr1[6];
        char tempStr2[6];
        char tempStr3[6];
        dtostrf((float(bms.battTemp1) / 100), 5, 2, tempStr1);
        dtostrf((float(bms.battTemp2) / 100), 5, 2, tempStr2);
        dtostrf((float(bms.battTemp3) / 100), 5, 2, tempStr3);
        WSContentSend_PD(PSTR("{s}%s " D_TEMPERATURE "{m}%s , %s , %s  °C{e}"), bms.manuf, tempStr1, tempStr2, tempStr3);
      }
      if (bms.setFields & BMS_TEMPL) {
        char tempStr4[6];
        char tempStr5[6];
        dtostrf((float(bms.battTempH)), 5, 0, tempStr4);
        dtostrf((float(bms.battTempL)), 5, 0, tempStr5);
        WSContentSend_PD(PSTR("{s}%s TempH/L{m}%s , %s   °C{e}"), bms.manuf, tempStr4, tempStr5);
      }
      if (bms.setFields & BMS_CELL_VOLT) {
        char ampStr1[6];
        char ampStr2[6];
        char ampStr3[6];
        char ampStr4[6];
        for (int i = 0; i < 12; i = i + 4) {
           dtostrf((float(bms.battCellVoltage[i]) / 1000), 5, 3, ampStr1);
           dtostrf((float(bms.battCellVoltage[i+1]) / 1000), 5, 3, ampStr2);
           dtostrf((float(bms.battCellVoltage[i+2]) / 1000), 5, 3, ampStr3);
           dtostrf((float(bms.battCellVoltage[i+3]) / 1000), 5, 3, ampStr4);
           WSContentSend_PD(PSTR("{s} S01 Zellspannung{m}%s  ,  %s  ,  %s  , %s {e}"), ampStr1, ampStr2, ampStr3, ampStr4);
//           WSContentSend_PD(PSTR("{s}%s {m}%s "), ampStr1, ampStr2);
        }   
           dtostrf((float(bms.battCellVoltage[12]) / 1000), 5, 3, ampStr1);
           dtostrf((float(bms.battCellVoltage[13]) / 1000), 5, 3, ampStr2);
           WSContentSend_PD(PSTR("{s} S01 Zellspannung{m}%s  ,  %s {e}"), ampStr1, ampStr2);
      }
      if (bms.setFields & BMS_CELL_DIFF) {
        char ampStr[6];
        dtostrf((float(bms.battMaxCellVoltDiff) / 10), 5, 1, ampStr);
        WSContentSend_PD(PSTR("{s}%s MaxCellVoltDiff{m}%s " D_UNIT_MILLIVOLT "{e}"), bms.manuf, ampStr);
      }
      if (bms.setFields & BMS_ENERGY) {
        char ampStr[6];
        dtostrf((float(bms.battEnergy) / 3600), 5, 1, ampStr);
        WSContentSend_PD(PSTR("{s}%s Energie{m}%s " D_UNIT_WATTHOUR "{e}"), bms.manuf, ampStr);
      }
      if (bms.setFields & BMS_BMSCUTUM) {
        WSContentSend_PD(PSTR("{s}%s BMScutum{m}%s {e}"), bms.manuf, bms.bmscutummessage);
      }
      if (bms.setFields & BMS_WARNINGS) {
        WSContentSend_PD(PSTR("{s}%s Warnings{m}%s {e}"), bms.manuf, bms.warningsmessage);
      }
      if (bms.setFields & BMS_ERRORS) {
        WSContentSend_PD(PSTR("{s}%s Errors{m}%s {e}"), bms.manuf, bms.errorsmessage);
      }
      if (bms.setFields & BMS_INPUTS) {
        WSContentSend_PD(PSTR("{s}%s Inputs{m}%s {e}"), bms.manuf, bms.inputsmessage);
      }
      if (bms.setFields & BMS_OUTPUTS) {
        WSContentSend_PD(PSTR("{s}%s Outputs{m}%s {e}"), bms.manuf, bms.outputsmessage);
      }
      
       

//    } else {
//      WSContentSend_PD(PSTR("{s}MCP2515 {m} Waiting for data{e}"));
//    }
  #endif // MCP2515_BMS_CLIENT
#endif  // USE_WEBSERVER
  }
}

/*********************************************************************************************\
 * Interface
\*********************************************************************************************/

bool Xsns87(uint32_t function)
{
  bool result = false;

  if (PinUsed(GPIO_MCP2515_CS, GPIO_ANY) && TasmotaGlobal.spi_enabled) {
    switch (function) {
      case FUNC_INIT:
        MCP2515_Init();
        break;
      case FUNC_EVERY_50_MSECOND:
        MCP2515_Read();
        break;
      case FUNC_JSON_APPEND:
        MCP2515_Show(1);
        break;

#ifdef USE_WEBSERVER
      case FUNC_WEB_SENSOR:
        MCP2515_Show(0);
        break;
#endif  // USE_WEBSERVER
    }
  }
  return result;
}

#endif  // USE_MCP2515
#endif // USE_SPI
